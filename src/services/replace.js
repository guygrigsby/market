export const updateTTS = (deck, newCard, oldCard) => {
  const os = deck.ObjectStates[0]
  console.log('deck Object States', os)
  console.log('deck Object State Contained Objects', os.ContainedObjects)
  // other object states are generated by us (eg tokens)
  for (let k = 0; os.ContainedObjects.length; k++) {
    const current = os.ContainedObjects[k]
    console.log('current', current)
    if (oldCard.name === current.Nickname) {
      console.log('replacing TTS', oldCard.name)
      if (!newCard.image_uris) {
        os.CustomDeck[k + 1].FaceURL = newCard.card_faces[0].normal
        os.CustomDeck[k + 1].BackURL = newCard.card_faces[1].normal
        break
      }
      os.CustomDeck[k + 1].FaceURL = newCard.image_uris.normal
      break
    }
  }

  return deck
}

export const binary = (deck, newC, oldName) => {
  const nd = [...deck]
  for (let i = deck.length / 2; ; ) {
    if (deck[i].name === oldName) {
      nd.splice(i, 1)
      break
    }
    if (deck[i].name > oldName) {
      i = (deck.length - i) / 2 + i
    } else {
      i = i - (deck.length - i) / 2
    }
  }
  let prev = deck.length / 2
  for (let i = prev; ; ) {
    if (i === prev || Math.abs(i - prev) === 1) {
      nd.splice(i, 0, newC)
      break
    }
    if (deck[i].name > oldName) {
      i = (deck.length - i) / 2 + i
    } else {
      i = i - (deck.length - i) / 2
    }
    prev = i
  }
}

export const naive = (deck, newC, oldC) => {
  const nd = [...deck]
  for (let i = 0; i < deck.length; i++) {
    const card = nd[i]
    if (oldC.name === card.name) {
      console.log('replacing', card.name)
      nd.splice(i, 1, newC)
      break
    }
  }

  return nd
}
